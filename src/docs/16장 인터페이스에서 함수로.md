
# 16장 인터페이스에서 함수로

## 개요
이 장은 **단일 책임을 가진 인터페이스를 함수 타입으로 대체할 수 있는지**를 다룬다.

객체 지향 설계에서는 “추상화 = 인터페이스”가 기본 선택처럼 여겨진다.<br>
하지만 코틀린에서는 단 하나의 동작만 필요하다면, 굳이 인터페이스를 유지해야 하는지 다시 질문할 수 있다.

핵심 질문은 다음과 같다.
> 이 추상화는 여러 책임과 상태를 가진 객체인가,  
> 아니면 단 하나의 동작을 표현하기 위한 전달 수단인가?

---

## 16.1 인터페이스 기반 캡슐화의 전형적인 형태

자바에서는 특정 동작을 캡슐화하기 위해 단일 메서드를 가진 인터페이스를 자주 사용한다.

```java
interface EmailSender {
    void send(Email email);
}
```

그리고 설정값을 포함한 구현체를 만든다.

```java
class SmtpEmailSender implements EmailSender {
    private final String host;
    private final String user;
    private final String password;

    public void send(Email email) {
        // send email
    }
}
```

이 구조의 목적은 다음과 같다.

- 동작 캡슐화
- 의존성 역전 (구현체가 아닌 인터페이스에 의존)
- 테스트 대체 가능성 확보

이 방식은 객체 지향 설계 원칙에 충실하며, 자바 환경에서는 매우 자연스러운 선택이다.

---

## 16.2 인터페이스가 실제로 제공하는 가치

위 구조를 다시 보면 다음과 같은 특징이 있다.

- 메서드는 단 하나
- 객체의 정체성(identity)은 중요하지 않음
- 상태는 설정값 보관 외에는 의미를 가지지 않음
- 호출자는 “무엇을 하는지”보다 “어떻게 전달되는지”만 관심 있음

즉, 이 인터페이스는 도메인 객체라기보다 행동을 전달하기 위한 래퍼에 가깝다. <br>
여기서 질문이 생긴다. <br>
"메서드가 하나뿐이라면 이 추상화는 정말 객체여야 할까?"

---

## 16.3 단일 동작은 함수로 표현할 수 있다

코틀린에서는 인터페이스 대신
함수 타입으로 동일한 의미를 표현할 수 있다.

```kotlin
typealias EmailSender = (Email) -> Unit
```
이제 이메일 발송은 “객체”가 아니라 “함수”다.

```kotlin
val sender: EmailSender = { email ->
    // send email
}
```
이 방식에서는
- 구현체 대신 행동 자체가 의존성으로 전달되고
- 호출자는 “무엇을 호출하는지”보다 “어떤 동작이 실행되는지”에 집중한다

의존성은 더 이상 구현체가 아니라 행동 자체에 의존한다.

---

## 16.4 팩토리에서 객체 대신 함수를 반환하기

설정값(host, user, password)을 캡슐화하는 역할은
객체가 아니라 함수를 생성하는 팩토리가 맡는다.

```kotlin
fun createEmailSender(
    host: String,
    user: String,
    password: String
): EmailSender =
    { email ->
        // 설정값을 캡처한 채 이메일 전송
    }
```

설정값은 함수의 클로저에 캡처된다

호출자는 설정을 알 필요 없이 함수를 사용한다

객체 없이도 캡슐화는 가능하다는 점을 보여준다.

---

## 16.5 인터페이스 → 함수 전환의 장점

### 불필요한 구조 제거
- 인터페이스 제거
- 구현 클래스 제거 
- 파일 수 감소

### 의도 표현 강화

```kotlin
fun notifyUser(sendEmail: EmailSender)
```

이 함수는 다음 의도를 직접적으로 드러낸다.
> “이메일을 보내는 방법을 받는다”

구현체 이름이나 타입 계층보다 행동 자체가 중심이된다.

## 테스트 단순화

```kotlin
val fakeSender: EmailSender = { /* do nothing */ }
```

- 목(Mock) 객체나 구현 클래스 없이
- 테스트용 동작을 즉석에서 주입 가능

---

## 16.6 여전히 인터페이스가 필요한 경우

모든 인터페이스가 함수로 대체될 수 있는 것은 아니다.<br>
다음과 같은 경우에는 인터페이스나 클래스가 더 적합하다.

- 여러 메서드를 함께 제공해야 할 때
- 상태와 수명 주기가 중요한 경우
- 명확한 도메인 개념(정체성)이 필요한 경우
- 자바 API 경계에 노출되는 타입

즉, 단일 동작인가? 가 핵심 판단 기준이다.

---

## 16.7 객체와 함수를 섞어 쓰기

코틀린에서는 객체도 함수처럼 만들 수 있다.

```kotlin
class EmailSender(
    private val host: String
) {
    operator fun invoke(email: Email) {
        // send email
    }
}
```

이 방식의 장점은 다음과 같다.

- 외부에서는 함수처럼 사용 가능
- 내부에서는 객체로 구조 유지 가능
- 객체 <-> 함수 전환 비용을 줄임

```kotlin
sender(email)
```

### 자바 개발자를 위한 설계 기준

자바에서는
> “추상화 = 인터페이스” 라는 사고가 기본값이다.

코틀린에서는 먼저 질문해야 한다.

- 이 추상화는 메서드가 몇 개인가?
- 상태와 정체성이 필요한가?
- 단순히 행동을 전달하기 위한 용도인가?

단일 동작이라면
인터페이스보다 함수가 더 정직한 표현이다.

---

## 요약

> 단 하나의 행동을 표현하는 추상화라면
> 인터페이스 대신 함수를 선택하라.

- 모든 추상화가 객체일 필요는 없다
- 행동은 함수로 표현할 수 있다
- 코틀린은 구조보다 의도를 드러내는 선택을 장려한다
