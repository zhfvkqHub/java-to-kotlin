# 14장 누적시키는 객체에서 변환으로

## 개요
이 장은 **가변 상태를 누적(accumulate)하는 객체 중심 설계**에서 벗어나  
**불변 데이터 + 변환(transform) 중심의 함수형 스타일**로 리팩터링하는 과정을 단계적으로 설명한다.

핵심 메시지는 다음과 같다.

> "계산 과정에서 상태를 변경하지 말고,  
> 데이터를 변환하여 새로운 값을 만들어라."

---

## 14.1 누적기(Accumulator)를 사용한 계산의 문제점

### 전통적인 접근
- `CostSummaryCalculator` 같은 **누적 객체**가 내부 상태를 가짐
- `addCost`, `summarise`, `reset` 등의 메서드로 상태를 변경
- 여러 통화(Money)를 누적한 뒤 최종 요약(CostSummary)을 생성

### 문제점
- **상태가 외부 흐름에 강하게 의존**
- 호출 순서에 따라 결과가 달라질 수 있음
- 테스트가 어렵고, 재사용성이 낮음
- 계산 로직이 객체 내부 상태에 숨겨짐

---

## 14.2 불변 데이터에 작용하는 함수로 리팩터링

### 핵심 아이디어
- 계산 로직을 **객체의 상태 변경**이 아니라  
  **컬렉션 변환(map, fold, reduce)** 으로 표현
- 중간 상태는 모두 지역 변수로 유지

### 변화 포인트
- `summarise()` 내부에서:
    - 통화별 그룹핑
    - 정렬
    - 변환
    - 합산
- 이 모든 과정을 **불변 컬렉션 변환 체인**으로 구성

---

## 14.3 CostSummary를 데이터 클래스로 만들기

### Before
- `CostSummary`가 내부에 `addLine()` 같은 변경 메서드를 가짐

### After
- `CostSummary`를 **순수 데이터 클래스**로 변경
- 모든 값은 생성자에서 한 번에 계산
- `fold`를 사용해 total 계산

```kotlin
val total = lines
    .map { it.toMoney }
    .fold(Money.zero(userCurrency), Money::add)
```

---

## 요약

> 누적하지 말고 변환하라.  
> 상태를 쌓지 말고, 값을 만들어라.

- 누적 객체는 숨겨진 상태를 만든다
    - 상태 기반 설계는 이해·테스트·재사용이 어려움
- 계산은 변환으로 표현하라
    - 컬렉션 → 컬렉션, 값 → 값
- 불변 데이터는 설계를 단순하게 만든다
- 함수형 스타일은 “수학적 사고”를 가능하게 한다
    - 입력이 같으면 출력도 같다
    - 로직을 지역적으로 이해 가능

