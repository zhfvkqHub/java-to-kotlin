# 15장 캡슐화한 컬렉션에서 타입 별명으로

## 개요
이 장은 컬렉션을 감싼 클래스를 도메인 객체로 유지할 것인지,  
아니면 코틀린의 `typealias`로 단순화할 수 있는지를 다룬다.

핵심 질문은 다음과 같다.

> 이 클래스는 실제로 행동과 규칙을 가진 도메인 객체인가,  
> 아니면 컬렉션에 의미만 부여한 이름인가?

---

## 15.1 캡슐화한 컬렉션의 전형적인 형태

자바에서는 컬렉션을 직접 노출하지 않기 위해
다음과 같은 래퍼 클래스를 자주 만든다.

```java
class Route {
  private final List<Journey> journeys;

  int size();
  Journey get(int index);
  Location departsFrom();
  Location arrivesAt();
}
```

이 클래스의 목적은:
- 컬렉션 보호
- 의미 있는 도메인 이름 제공
- 접근 제어

---

## 15.2 캡슐화가 실제로 제공하는 가치

Route 클래스가 제공하는 것을 살펴보면
- 내부 상태 없음
- 불변 규칙 없음
- 대부분의 메서드는 List 위임

즉, Route는 **행동을 가진 도메인 객체라기보다 List<Journey>에 이름만 붙인 구조**다.

---

## 15.3 행동을 확장 함수로 이동하기

Route가 제공하던 기능을  
확장 함수로 옮길 수 있다.

```kotlin
val Route.departsFrom: Location
    get() = first().departsFrom

val Route.arrivesAt: Location
    get() = last().arrivesAt
```

이로인해 데이터 구조는 단순해지고 의미 있는 API는 유지된다.

---

## 15.4 타입 별명(typealias) 도입

Route 클래스를 제거하고 다음과 같이 타입 별명을 정의한다.

```kotlin
typealias Route = List<Journey>
```


- 컴파일 타임에는 `List<Journey>`
- 코드 레벨에서는 `Route`라는 도메인 개념을 유지한다.

---

## 타입 별명의 장점

### 의미 있는 타입 이름
```kotlin
fun render(route: Route)
```

의도가 명확하고, 도메인 언어를 코드에 그대로 반영할 수 있다.

### 불필요한 래퍼 제거
- 생성자 제거
- 위임 메서드 제거
- 테스트 단순화

### 컬렉션 연산 그대로 사용
```kotlin
route.map { it.duration }
route.any { it.method == BUS }
```

---

## 타입 별명을 사용하면 안 되는 경우

다음 중 하나라도 해당하면 타입 별명을 쓰지 않고 클래스로 유지한다.

- 내부 불변 규칙이 존재
- 컬렉션 변경을 엄격히 통제해야 함
- 상태와 행위가 결합된 도메인 객체
- 컬렉션 외의 추가 필드 존재

---

## 상위 도메인과의 관계

```kotlin
data class Itinerary(
    val id: ItineraryId,
    val route: Route
)
```

Route는 의미 있는 타입으로 남고, Itinerary는 실제 도메인 객체가 된다.

---

## 자바 개발자를 위한 설계 기준

자바에서는 "컬렉션은 무조건 감싼다"는 관성이 있다.

코틀린에서는
- typealias
- 확장 함수
- 불변 컬렉션

을 통해서
클래스 수를 줄이면서도 의도를 더 명확히 표현할 수 있다.

---

## 요약

> 행동 없는 컬렉션 캡슐화라면  
> 클래스 대신 타입 별명을 선택하라.

- 모든 캡슐화 컬렉션이 도메인 객체는 아니다
- 행동이 없다면 타입 별명이 더 적합하다
- 코틀린은 구조보다 의미 표현에 집중하게 만든다
